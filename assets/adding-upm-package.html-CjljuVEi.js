import{_ as l,r as p,o as i,c as r,b as e,e as n,d as a,w as c,a as s}from"./app-D_mlLpjO.js";const d="/assets/package-add-form-sF2YTW3Y.png",m={},u=e("h1",{id:"添加upm软件包",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#添加upm软件包"},[e("span",null,"添加UPM软件包")])],-1),h=e("h2",{id:"upm软件包标准",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#upm软件包标准"},[e("span",null,"UPM软件包标准")])],-1),g=e("p",null,"OpenUPM要求软件包满足以下条件：",-1),k={href:"https://docs.unity.cn/cn/2020.2/Manual/cus-naming.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://unity3d.com/legal/terms-of-service/software",target:"_blank",rel:"noopener noreferrer"},f={href:"https://unity3d.com/legal/terms-of-service/software/package-guidelines",target:"_blank",rel:"noopener noreferrer"},M=e("li",null,"软件包应该提供其描述的功能，并被测试过。",-1),P=e("li",null,[n("包含软件包信息的"),e("code",null,"package.json"),n("文件，可以放置根路径下或任意的子文件夹中。")],-1),U={href:"https://spdx.org/licenses/",target:"_blank",rel:"noopener noreferrer"},y=e("li",null,"软件包需要被托管在Github上。",-1),x={href:"https://semver.org/",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"v1.1.0",-1),v=e("code",null,"1.1.0",-1),G=e("code",null,"1.1.1-preview",-1),A=e("code",null,"v2.0.0-preview.1",-1),j={href:"https://help.github.com/en/github/administering-a-repository/creating-releases",target:"_blank",rel:"noopener noreferrer"},w={href:"https://medium.com/openupm/how-to-maintain-upm-package-part-2-f352fbf5f87c",target:"_blank",rel:"noopener noreferrer"},L=e("li",null,"软件包应该小于512MB。",-1),O=s(`<h2 id="upm代码仓库的文件结构" tabindex="-1"><a class="header-anchor" href="#upm代码仓库的文件结构"><span>UPM代码仓库的文件结构</span></a></h2><p>OpenUPM构建管线支持以下三种主流的UPM代码仓库结构。</p><ul><li>UPM软件包位于根路径下</li><li>UPM软件包位于子文件夹中</li><li>UPM软件包位于某一Git分支的子文件夹中</li></ul><h3 id="upm软件包位于根路径下" tabindex="-1"><a class="header-anchor" href="#upm软件包位于根路径下"><span>UPM软件包位于根路径下</span></a></h3><p><code>package.json</code> 文件位于主分支的根路径，这是最简单的情况。</p><h3 id="upm软件包位于子文件夹中" tabindex="-1"><a class="header-anchor" href="#upm软件包位于子文件夹中"><span>UPM软件包位于子文件夹中</span></a></h3><p>Git的主分支通常是一个Unity项目（带有Assets文件夹）。<code>package.json</code>文件位于子文件夹中, 例如<code>Assets/package-name</code>或者<code>Packages/com.namespace.package-name</code>。Git标签是基于主分支的。OpenUPM构建管线将检测<code>package.json</code>文件的位置，并对其进行正确处理。</p><h3 id="upm软件包位于某一git分支的子文件夹中" tabindex="-1"><a class="header-anchor" href="#upm软件包位于某一git分支的子文件夹中"><span>UPM软件包位于某一Git分支的子文件夹中</span></a></h3><p>Git的主分支通常是一个Unity项目（带有Assets文件夹）。<code>package.json</code>文件位于子文件夹中，例如<code>Assets/package-name</code>或者<code>Packages/com.namespace.package-name</code>。该仓库另有一个<code>upm</code>分支，通常是使用<code>git subtree split/push</code>命令从主分支中修剪出的，目的是让<code>package.json</code>文件至于根目录下，并做一些特殊的准备工作（例如将<code>Samples</code>重命名为<code>Samples~</code>）。这样该<code>upm</code>分支就可以直接被Unity包管理器使用。这种结构下Git标签应基于upm分支，或者建立单独的<code>upm/x.y.z</code>Git标签，以便OpenUPM管线获取正确的信息。</p><h2 id="软件包yaml文件" tabindex="-1"><a class="header-anchor" href="#软件包yaml文件"><span>软件包YAML文件</span></a></h2><p>OpenUPM使用YAML文件存储软件包的元信息。例如：</p><div class="language-yaml" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token comment"># 软件包名称</span>
<span class="token key atrule">name</span><span class="token punctuation">:</span> com.namespace.unitypackageexample
<span class="token comment"># 软件包显示名称</span>
<span class="token key atrule">displayName</span><span class="token punctuation">:</span> Unity Package Example
<span class="token comment"># 软件包说明</span>
<span class="token key atrule">description</span><span class="token punctuation">:</span> An unity package example
<span class="token comment"># 代码仓库网址</span>
<span class="token key atrule">repoUrl</span><span class="token punctuation">:</span> <span class="token string">&#39;https://github.com/author/reponame&#39;</span>
<span class="token comment"># 分叉的父代码仓库网址</span>
<span class="token key atrule">parentRepoUrl</span><span class="token punctuation">:</span> <span class="token null important">null</span>
<span class="token comment"># spdx许可证编号</span>
<span class="token key atrule">licenseSpdxId</span><span class="token punctuation">:</span> MIT
<span class="token comment"># 许可证名称</span>
<span class="token key atrule">licenseName</span><span class="token punctuation">:</span> MIT License
<span class="token comment"># 主题标签列表</span>
<span class="token key atrule">topics</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> utilities
<span class="token comment"># Git标签过滤前缀</span>
<span class="token key atrule">gitTagPrefix</span><span class="token punctuation">:</span> <span class="token string">&#39;&#39;</span>
<span class="token comment"># Git标签忽略正则表达式</span>
<span class="token key atrule">gitTagIgnore</span><span class="token punctuation">:</span> <span class="token string">&#39;-master$&#39;</span>
<span class="token comment"># 最小构建版本</span>
<span class="token key atrule">minVersion</span><span class="token punctuation">:</span> <span class="token string">&#39;1.0.5&#39;</span>
<span class="token comment"># 主图片</span>
<span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">&#39;https://github.com/author/reponame/raw/master/path-of-img.png&#39;</span>
<span class="token comment"># 主图片缩放模式：cover (默认值) 或者 contain</span>
<span class="token key atrule">imageFit</span><span class="token punctuation">:</span> cover
<span class="token comment"># 自述路径</span>
<span class="token key atrule">readme</span><span class="token punctuation">:</span> <span class="token string">&#39;master:README.md&#39;</span>
<span class="token comment"># 软件包猎手的GitHub用户名</span>
<span class="token key atrule">hunter</span><span class="token punctuation">:</span> author
</code></pre></div><h2 id="使用软件包提交表单" tabindex="-1"><a class="header-anchor" href="#使用软件包提交表单"><span>使用软件包提交表单</span></a></h2>`,13),I=e("img",{src:d,alt:"软件包提交表单"},null,-1),N=s(`<p>通过自动测试后，该PR会被自动合并。CI会做大量集成工作，包括更新网站并通知构建管线。大约10~15分钟后，你可以通过访问<code>/packages/com.namespace.package-name</code>网址，来查看软件包的详细信息页面，并通过该页面的【<strong>版本</strong>】和【<strong>构建管线</strong>】模块了解更多的构建结果。</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>+--------------+      +--------------+      +---------+
| Package Form | +--&gt; | Pull Request | +--&gt; | Wait CI |
+--------------+      +--------------+      +---------+
</code></pre></div><h2 id="故障排除" tabindex="-1"><a class="header-anchor" href="#故障排除"><span>故障排除</span></a></h2><h3 id="处理没有git标签的代码仓库" tabindex="-1"><a class="header-anchor" href="#处理没有git标签的代码仓库"><span>处理没有Git标签的代码仓库</span></a></h3>`,4),Y={href:"https://medium.com/openupm/how-to-maintain-upm-package-part-2-f352fbf5f87c",target:"_blank",rel:"noopener noreferrer"},R=s(`<h3 id="处理主分支和upm分支的重复git标签" tabindex="-1"><a class="header-anchor" href="#处理主分支和upm分支的重复git标签"><span>处理主分支和UPM分支的重复Git标签</span></a></h3><p>代码仓库可能包含重复的版本标签。这可能是由CI工具创建的，一个用于主分支，另一个用于UPM分支。即</p><ul><li><code>1.0.0</code>和<code>upm/1.1.0</code></li><li><code>1.0.0</code>和<code>1.1.0-upm</code></li><li><code>1.0.0-master</code>和<code>1.1.0-upm</code></li></ul><p>在这种情况下，来自UPM分支的标签具有更高的优先级，而另一个则被忽略。</p><h3 id="处理失败的构建" tabindex="-1"><a class="header-anchor" href="#处理失败的构建"><span>处理失败的构建</span></a></h3><p>你可以在软件包详细信息页面上的【<strong>构建管线</strong>】部分检查失败的原因。最常见的问题是<strong>版本冲突/版本已存在</strong>，这意味着你已经发布了具有相同版本号的软件包。这通常是由于忘记更新<code>package.json</code>文件的版本号造成的。软件包的作者需要更新该版本号，然后重新标记错误的Git标签。若OpenUPM检测到相关的Git标签已被重新标记，则构建管线将重新构建失败的版本。</p><p>然而，构建管线不会去重建已经成功发布的版本，即使是对应的Git标签被重新标记或删除。因为更改已经发行的版本是一种不被鼓励的行为，特别对于开放的软件仓库来说更是如此。如果打算修复一个Bug，建议软件包的作者通过提升版本号，并创建新的Git标签来修复该问题。</p><h3 id="处理复合软件包仓库-monorepos" tabindex="-1"><a class="header-anchor" href="#处理复合软件包仓库-monorepos"><span>处理复合软件包仓库（Monorepos）</span></a></h3><p>复合软件包仓库（Monorepos）在单个代码仓库中包含多个软件包。通常结构如下：</p><div class="language-text" data-ext="text" data-title="text"><pre class="language-text"><code>Packages/
  com.namespace.foo/
    package.json
  com.namespace.bar/
    package.json
</code></pre></div><p>复合软件包仓库（Monorepos）应提交多个软件包YAML到OpenUPM平台中。需要注意的是，</p><ul><li>如果你为每个新版本，都提升所有软件包的版本号。那么它将可以正常工作。我们的构建管线将分别处理每个程序包提交，并找到相关的package.json进行处理。</li><li>如果你为某个单独的软件包发布新版本，但其他的软件包版本则保持不动，你需要使用一个Git标记的前缀来区分每个软件包。例如<code>com.namespace.bar/1.0.0</code>和<code>com.namespace.foo/1.0.0</code>。然后填写软件包YAML文件的<code>gitTagPrefix</code>字段。例如，软件包<code>com.namespace.bar</code>应该写入<code>gitTagPrefix: &quot;com.namespace.bar/&quot;</code>，以避免浪费构建管线的资源去构建实际上未更新的软件包。</li></ul>`,12);function T(z,C){const t=p("ExternalLinkIcon"),o=p("RouteLink");return i(),r("div",null,[u,h,g,e("ul",null,[e("li",null,[n("软件包名称应该符合"),e("a",k,[n("UPM命名约定"),a(t)])]),e("li",null,[n("软件包应该符合"),e("a",_,[n("Unity使用条例"),a(t)]),n("和"),e("a",f,[n("软件包准则"),a(t)]),n("。")]),M,P,e("li",null,[n("软件包应该使用开源许可证。建议从"),e("a",U,[n("spdx许可证列表"),a(t)]),n("中选择。")]),y,e("li",null,[n("软件包应该通过Git标签进行版本控制，且符合"),e("a",x,[n("Semantic Versioning 语义式版本"),a(t)]),n("的标准。例如"),b,n("，"),v,n("，"),G,n("或"),A,n("。建议使用"),e("a",j,[n("GitHub发行"),a(t)]),n("页面或使用"),e("a",w,[n("持续集成工具"),a(t)]),n("来创建含版本信息的Git标签。")]),L]),O,e("p",null,[n("软件包猎手可以使用"),a(o,{to:"/packages/add/"},{default:c(()=>[n("软件包提交表单")]),_:1}),n("来提交软件包的YAML文件。该表单将指导你填写所需的信息，生成YAML文件，然后在浏览器中生成合并请求（Pull Request）并提交到GitHub。")]),e("p",null,[a(o,{to:"/packages/add/"},{default:c(()=>[I]),_:1})]),N,e("p",null,[n("请在原作者的代码仓库中创建一个工单（Issue），以申请建立含有有效版本信息的Git标签。要了解如何使用GitHub Actions来自动化该过程，请参考"),e("a",Y,[n("这篇英文教程"),a(t)]),n("。")]),R])}const S=l(m,[["render",T],["__file","adding-upm-package.html.vue"]]),V=JSON.parse('{"path":"/zh/docs/adding-upm-package.html","title":"添加UPM软件包","lang":"zh-CN","frontmatter":{"description":"添加UPM软件包 UPM软件包标准 OpenUPM要求软件包满足以下条件： 软件包名称应该符合UPM命名约定 软件包应该符合Unity使用条例和软件包准则。 软件包应该提供其描述的功能，并被测试过。 包含软件包信息的package.json文件，可以放置根路径下或任意的子文件夹中。 软件包应该使用开源许可证。建议从spdx许可证列表中选择。 软件包需要...","head":[["link",{"rel":"canonical","href":"https://openupm.cn/zh/docs/adding-upm-package.html"}],["meta",{"property":"og:url","content":"https://openupm.cn/zh/docs/adding-upm-package.html"}],["meta",{"property":"og:site_name","content":"OpenUPM中文网"}],["meta",{"property":"og:title","content":"添加UPM软件包"}],["meta",{"property":"og:description","content":"添加UPM软件包 UPM软件包标准 OpenUPM要求软件包满足以下条件： 软件包名称应该符合UPM命名约定 软件包应该符合Unity使用条例和软件包准则。 软件包应该提供其描述的功能，并被测试过。 包含软件包信息的package.json文件，可以放置根路径下或任意的子文件夹中。 软件包应该使用开源许可证。建议从spdx许可证列表中选择。 软件包需要..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://openupm.cn/images/openupm-twitter.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"添加UPM软件包"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"添加UPM软件包\\",\\"image\\":[\\"https://openupm.cn/images/openupm-twitter.png\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"UPM软件包标准","slug":"upm软件包标准","link":"#upm软件包标准","children":[]},{"level":2,"title":"UPM代码仓库的文件结构","slug":"upm代码仓库的文件结构","link":"#upm代码仓库的文件结构","children":[{"level":3,"title":"UPM软件包位于根路径下","slug":"upm软件包位于根路径下","link":"#upm软件包位于根路径下","children":[]},{"level":3,"title":"UPM软件包位于子文件夹中","slug":"upm软件包位于子文件夹中","link":"#upm软件包位于子文件夹中","children":[]},{"level":3,"title":"UPM软件包位于某一Git分支的子文件夹中","slug":"upm软件包位于某一git分支的子文件夹中","link":"#upm软件包位于某一git分支的子文件夹中","children":[]}]},{"level":2,"title":"软件包YAML文件","slug":"软件包yaml文件","link":"#软件包yaml文件","children":[]},{"level":2,"title":"使用软件包提交表单","slug":"使用软件包提交表单","link":"#使用软件包提交表单","children":[]},{"level":2,"title":"故障排除","slug":"故障排除","link":"#故障排除","children":[{"level":3,"title":"处理没有Git标签的代码仓库","slug":"处理没有git标签的代码仓库","link":"#处理没有git标签的代码仓库","children":[]},{"level":3,"title":"处理主分支和UPM分支的重复Git标签","slug":"处理主分支和upm分支的重复git标签","link":"#处理主分支和upm分支的重复git标签","children":[]},{"level":3,"title":"处理失败的构建","slug":"处理失败的构建","link":"#处理失败的构建","children":[]},{"level":3,"title":"处理复合软件包仓库（Monorepos）","slug":"处理复合软件包仓库-monorepos","link":"#处理复合软件包仓库-monorepos","children":[]}]}],"filePathRelative":"zh/docs/adding-upm-package.md","autoDesc":true}');export{S as comp,V as data};
